"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Core = require("@antv/l7-core");
var _l7Utils = require("@antv/l7-utils");
var _lodash = require("lodash");
var _BaseModel2 = _interopRequireDefault(require("../../core/BaseModel"));
var _interface = require("../../core/interface");
var _triangulation = require("../../core/triangulation");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/* babel-plugin-inline-import '../shaders/linearLine/line_linear_frag.glsl' */
var linear_line_frag = "\nvarying vec4 v_Color;\n#pragma include \"picking\"\nvoid main() {\n\n  gl_FragColor = v_Color; // \u5168\u5C40\u900F\u660E\u5EA6\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
/* babel-plugin-inline-import '../shaders/linearLine/line_linear_vert.glsl' */
var linear_line_vert = "\nattribute float a_Miter;\nattribute vec2 a_Size;\nattribute vec3 a_Normal;\nattribute vec3 a_Position;\n\n// dash line\nattribute float a_Total_Distance;\nattribute vec2 a_DistanceAndIndex;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nuniform float u_heightfixed: 0.0;\nuniform float u_vertexScale: 1.0;\nuniform float u_raisingHeight: 0.0;\nuniform float u_opacity : 1.0;\nuniform sampler2D u_texture;\nuniform float u_linearDir: 1.0;\nvarying vec4 v_Color;\n\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\n\nvoid main() {\n\n\n  vec3 size = a_Miter * setPickingSize(a_Size.x) * reverse_offset_normal(a_Normal);\n  \n  vec2 offset = project_pixel(size.xy);\n\n  float lineDistance = a_DistanceAndIndex.x;\n  float currentLinePointRatio = lineDistance / a_Total_Distance;\n \n\n  float lineOffsetWidth = length(offset + offset * sign(a_Miter)); // \u7EBF\u6A2A\u5411\u504F\u79FB\u7684\u8DDD\u79BB\uFF08\u5411\u4E24\u4FA7\u504F\u79FB\u7684\u548C\uFF09\n  float linePixelSize = project_pixel(a_Size.x) * 2.0;  // \u5B9A\u70B9\u4F4D\u7F6E\u504F\u79FB\uFF0C\u6309\u5730\u56FE\u7B49\u7EA7\u7F29\u653E\u540E\u7684\u8DDD\u79BB \u5355\u4FA7 * 2\n  float texV = lineOffsetWidth/linePixelSize; // \u7EBF\u56FE\u5C42\u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\u503C\n\n  float linearRadio =currentLinePointRatio; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n  if(u_linearDir < 1.0) {\n    linearRadio = texV;\n  }\n\n  v_Color = texture2D(u_texture, vec2(linearRadio, 0.5));\n\n  v_Color.a *= u_opacity; // \u5168\u5C40\u900F\u660E\u5EA6\n\n\n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0));\n\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, a_Size.y, 1.0));\n\n  float h = float(a_Position.z) * u_vertexScale; // \u7EBF\u9876\u70B9\u7684\u9AD8\u5EA6 - \u517C\u5BB9\u4E0D\u5B58\u5728\u7B2C\u4E09\u4E2A\u6570\u503C\u7684\u60C5\u51B5 vertex height\n  float lineHeight = a_Size.y; // size \u7B2C\u4E8C\u4E2A\u53C2\u6570\u4EE3\u8868\u7684\u9AD8\u5EA6 [linewidth, lineheight]\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    lineHeight *= 0.2; // \u4FDD\u6301\u548C amap/mapbox \u4E00\u81F4\u7684\u6548\u679C\n    h *= 0.2;\n    if(u_heightfixed < 1.0) {\n      lineHeight = project_pixel(a_Size.y);\n    }\n    gl_Position = u_Mvp * (vec4(project_pos.xy + offset, lineHeight + h + u_raisingHeight, 1.0));\n  } else {\n    // mapbox -  amap\n    \n    // \u517C\u5BB9 mapbox \u5728\u7EBF\u9AD8\u5EA6\u4E0A\u7684\u6548\u679C\u8868\u73B0\u57FA\u672C\u4E00\u81F4\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      // mapbox\n      // \u4FDD\u6301\u9AD8\u5EA6\u76F8\u5BF9\u4E0D\u53D8\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n      h *= mapboxZoomScale;\n      h += u_raisingHeight * mapboxZoomScale;\n      if(u_heightfixed > 0.0) {\n        lineHeight *= mapboxZoomScale;\n      }\n      \n    } else {\n      // amap\n      h += u_raisingHeight;\n      // lineHeight \u9876\u70B9\u504F\u79FB\u9AD8\u5EA6\n      if(u_heightfixed < 1.0) {\n        lineHeight *= pow(2.0, 20.0 - u_Zoom);\n      }\n    }\n\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, lineHeight + h, 1.0));\n  }\n\n  setPickingColor(a_PickingColor);\n}\n";
var LinearLineModel = /*#__PURE__*/function (_BaseModel) {
  (0, _inherits2.default)(LinearLineModel, _BaseModel);
  var _super = _createSuper(LinearLineModel);
  function LinearLineModel() {
    var _this;
    (0, _classCallCheck2.default)(this, LinearLineModel);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "updateTexture", function () {
      var createTexture2D = _this.rendererService.createTexture2D;
      if (_this.colorTexture) {
        _this.colorTexture.destroy();
      }
      var _ref = _this.layer.getLayerConfig(),
        rampColors = _ref.rampColors;
      var imageData = (0, _l7Utils.generateColorRamp)(rampColors);
      _this.colorTexture = createTexture2D({
        data: new Uint8Array(imageData.data),
        width: imageData.width,
        height: imageData.height,
        wrapS: _l7Core.gl.CLAMP_TO_EDGE,
        wrapT: _l7Core.gl.CLAMP_TO_EDGE,
        min: _l7Core.gl.NEAREST,
        mag: _l7Core.gl.NEAREST,
        flipY: false
      });
    });
    return _this;
  }
  (0, _createClass2.default)(LinearLineModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref2 = this.layer.getLayerConfig(),
        _ref2$opacity = _ref2.opacity,
        opacity = _ref2$opacity === void 0 ? 1 : _ref2$opacity,
        _ref2$vertexHeightSca = _ref2.vertexHeightScale,
        vertexHeightScale = _ref2$vertexHeightSca === void 0 ? 20.0 : _ref2$vertexHeightSca,
        _ref2$raisingHeight = _ref2.raisingHeight,
        raisingHeight = _ref2$raisingHeight === void 0 ? 0 : _ref2$raisingHeight,
        _ref2$heightfixed = _ref2.heightfixed,
        heightfixed = _ref2$heightfixed === void 0 ? false : _ref2$heightfixed,
        _ref2$linearDir = _ref2.linearDir,
        linearDir = _ref2$linearDir === void 0 ? _interface.LinearDir.VERTICAL : _ref2$linearDir;
      if (this.rendererService.getDirty()) {
        this.colorTexture.bind();
      }
      return {
        u_linearDir: linearDir === _interface.LinearDir.VERTICAL ? 1.0 : 0.0,
        u_opacity: (0, _lodash.isNumber)(opacity) ? opacity : 1,
        // 纹理支持参数
        u_texture: this.colorTexture,
        // 贴图

        // 是否固定高度
        u_heightfixed: Number(heightfixed),
        // 顶点高度 scale
        u_vertexScale: vertexHeightScale,
        u_raisingHeight: Number(raisingHeight)
      };
    }
  }, {
    key: "initModels",
    value: function () {
      var _initModels = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this.updateTexture();
              return _context.abrupt("return", this.buildModels());
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function initModels() {
        return _initModels.apply(this, arguments);
      }
      return initModels;
    }()
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$colorTexture;
      (_this$colorTexture = this.colorTexture) === null || _this$colorTexture === void 0 ? void 0 : _this$colorTexture.destroy();
    }
  }, {
    key: "buildModels",
    value: function () {
      var _buildModels = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        var _ref3, _ref3$depth, depth, model;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _ref3 = this.layer.getLayerConfig(), _ref3$depth = _ref3.depth, depth = _ref3$depth === void 0 ? false : _ref3$depth;
              this.layer.triangulation = _triangulation.LineTriangulation;
              _context2.next = 4;
              return this.layer.buildLayerModel({
                moduleName: 'lineRampColors',
                vertexShader: linear_line_vert,
                fragmentShader: linear_line_frag,
                triangulation: _triangulation.LineTriangulation,
                depth: {
                  enable: depth
                }
              });
            case 4:
              model = _context2.sent;
              return _context2.abrupt("return", [model]);
            case 6:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function buildModels() {
        return _buildModels.apply(this, arguments);
      }
      return buildModels;
    }()
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'distanceAndIndex',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_DistanceAndIndex',
          buffer: {
            // give the WebGL driver a hint that this buffer may change
            usage: _l7Core.gl.STATIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal, vertexIndex) {
            return vertexIndex === undefined ? [vertex[3], 10] : [vertex[3], vertexIndex];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'total_distance',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_Total_Distance',
          buffer: {
            // give the WebGL driver a hint that this buffer may change
            usage: _l7Core.gl.STATIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex) {
            return [vertex[5]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            // give the WebGL driver a hint that this buffer may change
            usage: _l7Core.gl.DYNAMIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 2,
          update: function update(feature) {
            var _feature$size = feature.size,
              size = _feature$size === void 0 ? 1 : _feature$size;
            return Array.isArray(size) ? [size[0], size[1]] : [size, 0];
          }
        }
      });

      // point layer size;
      this.styleAttributeService.registerStyleAttribute({
        name: 'normal',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_Normal',
          buffer: {
            // give the WebGL driver a hint that this buffer may change
            usage: _l7Core.gl.STATIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {
            return normal;
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'miter',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_Miter',
          buffer: {
            // give the WebGL driver a hint that this buffer may change
            usage: _l7Core.gl.STATIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex) {
            return [vertex[4]];
          }
        }
      });
    }
  }]);
  return LinearLineModel;
}(_BaseModel2.default);
exports.default = LinearLineModel;