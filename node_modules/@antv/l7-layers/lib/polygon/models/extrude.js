"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _l7Core = require("@antv/l7-core");
var _l7Utils = require("@antv/l7-utils");
var _BaseModel2 = _interopRequireDefault(require("../../core/BaseModel"));
var _triangulation = require("../../core/triangulation");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/* babel-plugin-inline-import '../shaders/extrude/polygon_extrude_frag.glsl' */
var polygonExtrudeFrag = "uniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\nuniform float u_linearColor: 0;\n\nuniform float u_topsurface: 1.0;\nuniform float u_sidesurface: 1.0;\n\nvarying vec4 v_Color;\n\n#pragma include \"picking\"\n\nvoid main() {\n\n\n     // top face\n    if(u_topsurface < 1.0) {\n      discard;\n    }\n\n    gl_FragColor = v_Color;\n  \n\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
/* babel-plugin-inline-import '../shaders/extrude/polygon_extrude_vert.glsl' */
var polygonExtrudeVert = "precision highp float;\n\n#define ambientRatio 0.5\n#define diffuseRatio 0.3\n#define specularRatio 0.2\n\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec3 a_Normal;\nattribute float a_Size;\nattribute vec3 a_uvs;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\nuniform float u_linearColor: 0;\n\nuniform float u_topsurface: 1.0;\nuniform float u_sidesurface: 1.0;\n\nvarying vec4 v_Color;\nuniform float u_heightfixed: 0.0; // \u9ED8\u8BA4\u4E0D\u56FA\u5B9A\nuniform float u_raisingHeight: 0.0;\n\n#pragma include \"projection\"\n#pragma include \"light\"\n#pragma include \"picking\"\n\nvoid main() {\n \n  float isSide = a_Position.z;\n float topU = a_uvs[0];\n float topV = 1.0 - a_uvs[1];\n float sidey = a_uvs[2];\n\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\n  float lightWeight = calc_lighting(pos);\n\n  vec4 project_pos = project_position(pos);\n\n  if(u_heightfixed > 0.0) { // \u5224\u65AD\u51E0\u4F55\u4F53\u662F\u5426\u56FA\u5B9A\u9AD8\u5EA6\n    project_pos.z = a_Position.z * a_Size;\n    project_pos.z += u_raisingHeight;\n\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n      project_pos.z *= mapboxZoomScale;\n      project_pos.z += u_raisingHeight * mapboxZoomScale;\n    }\n  }\n\n\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // gl_Position = u_Mvp * (vec4(project_pos.xyz * vec3(1.0, 1.0, -1.0), 1.0));\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n\n  // Tip: \u90E8\u5206\u673A\u578B GPU \u8BA1\u7B97\u7CBE\u5EA6\u517C\u5BB9\n  if(isSide < 0.999) {\n    // side face\n    // if(u_sidesurface < 1.0) {\n    //   discard;\n    // }\n\n    if(u_linearColor == 1.0) {\n      vec4 linearColor = mix(u_targetColor, u_sourceColor, sidey);\n      linearColor.rgb *= lightWeight;\n      v_Color = linearColor;\n    } else {\n      v_Color = a_Color;\n    }\n\n  } else {\n    v_Color = a_Color;\n  }\n\n  v_Color = vec4(v_Color.rgb * lightWeight, v_Color.w * opacity);\n\n\n  setPickingColor(a_PickingColor);\n}\n"; // extrude
/* babel-plugin-inline-import '../shaders/extrude/polygon_extrudetex_frag.glsl' */
var polygonExtrudeTexFrag = "uniform sampler2D u_texture;\nuniform float u_opacity: 1.0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\nuniform float u_linearColor: 0;\n\nuniform float u_topsurface: 1.0;\nuniform float u_sidesurface: 1.0;\n\nvarying vec4 v_Color;\nvarying vec3 v_uvs;\nvarying vec2 v_texture_data;\n\n\n#pragma include \"picking\"\n\nvoid main() {\n  float opacity = u_opacity;\n  float isSide = v_texture_data.x;\n  float lightWeight = v_texture_data.y;\n  float topU = v_uvs[0];\n  float topV = 1.0 - v_uvs[1];\n  float sidey = v_uvs[2];\n  // Tip: \u90E8\u5206\u673A\u578B GPU \u8BA1\u7B97\u7CBE\u5EA6\u517C\u5BB9\n  if(isSide < 0.999) {// \u662F\u5426\u662F\u8FB9\u7F18\n    // side face\n    if(u_sidesurface < 1.0) {\n      discard;\n    }\n\n    if(u_linearColor == 1.0) {\n      vec4 linearColor = mix(u_targetColor, u_sourceColor, sidey);\n      linearColor.rgb *= lightWeight;\n      gl_FragColor = linearColor;\n    } else {\n      gl_FragColor = v_Color;\n    }\n  } else {\n\n     // top face\n    if(u_topsurface < 1.0) {\n      discard;\n    }\n\n    gl_FragColor = texture2D(u_texture, vec2(topU, topV));\n    // gl_FragColor = vec4(1.0, 0., 0., 1.0);\n  }\n  \n\n  gl_FragColor.a *= opacity;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n"; // texture
/* babel-plugin-inline-import '../shaders/extrude/polygon_extrudetex_vert.glsl' */
var polygonExtrudeTexVert = "precision highp float;\n\n#define ambientRatio 0.5\n#define diffuseRatio 0.3\n#define specularRatio 0.2\n\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec3 a_Normal;\nattribute float a_Size;\nattribute vec3 a_uvs;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform sampler2D u_texture;\n\n\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\nuniform float u_topsurface: 1.0;\nuniform float u_sidesurface: 1.0;\nvarying vec4 v_Color;\nuniform float u_heightfixed: 0.0; // \u9ED8\u8BA4\u4E0D\u56FA\u5B9A\nuniform float u_raisingHeight: 0.0;\nuniform float u_linearColor: 0.0;\n\nvarying vec2 v_texture_data;\nvarying vec3 v_uvs;\n\n#pragma include \"projection\"\n#pragma include \"light\"\n#pragma include \"picking\"\n\nvoid main() {\n \n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\n  float lightWeight = calc_lighting(pos);\n  vec4 project_pos = project_position(pos);\n  v_uvs = a_uvs;\n\n  v_texture_data = vec2(a_Position.z, lightWeight);\n\n  if(u_heightfixed > 0.0) { // \u5224\u65AD\u51E0\u4F55\u4F53\u662F\u5426\u56FA\u5B9A\u9AD8\u5EA6\n    project_pos.z = a_Position.z * a_Size;\n    project_pos.z += u_raisingHeight;\n\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n      project_pos.z *= mapboxZoomScale;\n      project_pos.z += u_raisingHeight * mapboxZoomScale;\n    }\n  }\n\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // gl_Position = u_Mvp * (vec4(project_pos.xyz * vec3(1.0, 1.0, -1.0), 1.0));\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n\n\n\n\n  setPickingColor(a_PickingColor);\n}\n"; // extrude picking
/* babel-plugin-inline-import '../shaders/extrude/polygon_extrude_picklight_frag.glsl' */
var polygonExtrudePickLightFrag = "uniform float u_opacity: 1.0;\nuniform vec4 u_sourceColor;\nuniform vec4 u_targetColor;\nuniform float u_linearColor: 0;\n\nuniform float u_topsurface: 1.0;\nuniform float u_sidesurface: 1.0;\n\nvarying vec4 v_Color;\nvarying vec3 v_uvs;\nvarying vec2 v_texture_data;\n\n#pragma include \"picking\"\n\nvoid main() {\n  float opacity = u_opacity;\n  float isSide =  v_texture_data.x;\n  float sidey = v_uvs[2];\n  float lightWeight = v_texture_data.y;\n\n  // Tip: \u90E8\u5206\u673A\u578B GPU \u8BA1\u7B97\u7CBE\u5EA6\u517C\u5BB9\n  if(isSide < 0.999) {\n    // side face\n    if(u_sidesurface < 1.0) {\n      discard;\n    }\n    \n    if( u_linearColor == 1.0) {\n      // side use linear\n      vec4 linearColor = mix(u_targetColor, u_sourceColor, sidey);\n      linearColor.rgb *= lightWeight;\n      gl_FragColor = linearColor;\n    } else {\n      // side notuse linear\n       gl_FragColor = v_Color;\n    }\n  } else {\n    // top face\n    if(u_topsurface < 1.0) {\n      discard;\n    }\n    gl_FragColor = v_Color;\n  }\n\n  gl_FragColor.a *= opacity;\n  gl_FragColor = filterColorAlpha(gl_FragColor, lightWeight);\n}\n";
/* babel-plugin-inline-import '../shaders/extrude/polygon_extrude_picklight_vert.glsl' */
var polygonExtrudePickLightVert = "precision highp float;\n\n#define ambientRatio 0.5\n#define diffuseRatio 0.3\n#define specularRatio 0.2\n\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec3 a_Normal;\nattribute float a_Size;\nattribute vec3 a_uvs;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nuniform float u_heightfixed: 0.0; // \u9ED8\u8BA4\u4E0D\u56FA\u5B9A\nuniform float u_raisingHeight: 0.0;\n\nvarying vec2 v_texture_data;\nvarying vec3 v_uvs;\nvarying vec4 v_Color;\n\n\n#pragma include \"projection\"\n#pragma include \"light\"\n#pragma include \"picking\"\n\nvoid main() {\n\n\n  v_uvs = a_uvs;\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\n  vec4 project_pos = project_position(pos);\n\n  if(u_heightfixed > 0.0) { // \u5224\u65AD\u51E0\u4F55\u4F53\u662F\u5426\u56FA\u5B9A\u9AD8\u5EA6\n    project_pos.z = a_Position.z * a_Size;\n    project_pos.z += u_raisingHeight;\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n      project_pos.z *= mapboxZoomScale;\n      project_pos.z += u_raisingHeight * mapboxZoomScale;\n    }\n  }\n\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    // gl_Position = u_Mvp * (vec4(project_pos.xyz * vec3(1.0, 1.0, -1.0), 1.0));\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n\n  float lightWeight = calc_lighting(pos);\n  v_texture_data = vec2(a_Position.z,lightWeight);\n\n  v_Color = vec4(a_Color.rgb * lightWeight, a_Color.w);\n\n  setPickingColor(a_PickingColor);\n}\n";
var ExtrudeModel = /*#__PURE__*/function (_BaseModel) {
  (0, _inherits2.default)(ExtrudeModel, _BaseModel);
  var _super = _createSuper(ExtrudeModel);
  function ExtrudeModel() {
    (0, _classCallCheck2.default)(this, ExtrudeModel);
    return _super.apply(this, arguments);
  }
  (0, _createClass2.default)(ExtrudeModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
        _ref$heightfixed = _ref.heightfixed,
        heightfixed = _ref$heightfixed === void 0 ? false : _ref$heightfixed,
        _ref$raisingHeight = _ref.raisingHeight,
        raisingHeight = _ref$raisingHeight === void 0 ? 0 : _ref$raisingHeight,
        _ref$topsurface = _ref.topsurface,
        topsurface = _ref$topsurface === void 0 ? true : _ref$topsurface,
        _ref$sidesurface = _ref.sidesurface,
        sidesurface = _ref$sidesurface === void 0 ? true : _ref$sidesurface,
        sourceColor = _ref.sourceColor,
        targetColor = _ref.targetColor;

      // 转化渐变色
      var useLinearColor = 0; // 默认不生效
      var sourceColorArr = [1, 1, 1, 1];
      var targetColorArr = [1, 1, 1, 1];
      if (sourceColor && targetColor) {
        sourceColorArr = (0, _l7Utils.rgb2arr)(sourceColor);
        targetColorArr = (0, _l7Utils.rgb2arr)(targetColor);
        useLinearColor = 1;
      }
      return (0, _objectSpread2.default)({
        // 控制侧面和顶面的显示隐藏
        u_topsurface: Number(topsurface),
        u_sidesurface: Number(sidesurface),
        u_heightfixed: Number(heightfixed),
        u_raisingHeight: Number(raisingHeight),
        // 渐变色支持参数
        u_linearColor: useLinearColor,
        u_sourceColor: sourceColorArr,
        u_targetColor: targetColorArr,
        u_texture: this.texture
      }, this.getStyleAttribute());
    }
  }, {
    key: "initModels",
    value: function () {
      var _initModels = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.loadTexture();
            case 2:
              return _context.abrupt("return", this.buildModels());
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function initModels() {
        return _initModels.apply(this, arguments);
      }
      return initModels;
    }()
  }, {
    key: "buildModels",
    value: function () {
      var _buildModels = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        var _this$getShaders, frag, vert, type, model;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _this$getShaders = this.getShaders(), frag = _this$getShaders.frag, vert = _this$getShaders.vert, type = _this$getShaders.type;
              _context2.next = 3;
              return this.layer.buildLayerModel({
                moduleName: type,
                vertexShader: vert,
                fragmentShader: frag,
                inject: this.getInject(),
                triangulation: _triangulation.PolygonExtrudeTriangulation
              });
            case 3:
              model = _context2.sent;
              return _context2.abrupt("return", [model]);
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function buildModels() {
        return _buildModels.apply(this, arguments);
      }
      return buildModels;
    }()
  }, {
    key: "getShaders",
    value: function getShaders() {
      var _ref2 = this.layer.getLayerConfig(),
        pickLight = _ref2.pickLight,
        mapTexture = _ref2.mapTexture;
      if (mapTexture) {
        return {
          frag: polygonExtrudeTexFrag,
          vert: polygonExtrudeTexVert,
          type: 'polygonExtrudeTexture'
        };
      }
      if (pickLight) {
        return {
          frag: polygonExtrudePickLightFrag,
          vert: polygonExtrudePickLightVert,
          type: 'polygonExtrudePickLight'
        };
      } else {
        return {
          frag: polygonExtrudeFrag,
          vert: polygonExtrudeVert,
          type: 'polygonExtrude'
        };
      }
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture;
      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var bbox = this.layer.getSource().extent;
      var bounds = bbox;
      var layerCenter = this.layer.coordCenter || this.layer.getSource().center;
      var lngLen = bounds[2] - bounds[0];
      var latLen = bounds[3] - bounds[1];
      if (this.mapService.version === 'GAODE2.x') {
        // @ts-ignore
        var _this$mapService$coor = this.mapService.coordToAMap2RelativeCoordinates([bbox[0], bbox[1]], layerCenter),
          _this$mapService$coor2 = (0, _slicedToArray2.default)(_this$mapService$coor, 2),
          minX = _this$mapService$coor2[0],
          minY = _this$mapService$coor2[1];
        // @ts-ignore
        var _this$mapService$coor3 = this.mapService.coordToAMap2RelativeCoordinates([bbox[2], bbox[3]], layerCenter),
          _this$mapService$coor4 = (0, _slicedToArray2.default)(_this$mapService$coor3, 2),
          maxX = _this$mapService$coor4[0],
          maxY = _this$mapService$coor4[1];
        lngLen = maxX - minX;
        latLen = maxY - minY;
        bounds = [minX, minY, maxX, maxY];
      }
      this.styleAttributeService.registerStyleAttribute({
        name: 'uvs',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_uvs',
          buffer: {
            // give the WebGL driver a hint that this buffer may change
            usage: _l7Core.gl.STATIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex) {
            var lng = vertex[0];
            var lat = vertex[1];
            // console.log((lng - bounds[0]) / lngLen, (lat - bounds[1]) / latLen, vertex[4])
            // 临时 兼容高德V2
            return [(lng - bounds[0]) / lngLen, (lat - bounds[1]) / latLen, vertex[4]];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'normal',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_Normal',
          buffer: {
            // give the WebGL driver a hint that this buffer may change
            usage: _l7Core.gl.STATIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 3,
          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {
            return normal;
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: _l7Core.gl.DYNAMIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 1,
          update: function update(feature) {
            var _feature$size = feature.size,
              size = _feature$size === void 0 ? 10 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
    }
  }, {
    key: "loadTexture",
    value: function () {
      var _loadTexture = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
        var _this = this;
        var _ref3, mapTexture, createTexture2D;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _ref3 = this.layer.getLayerConfig(), mapTexture = _ref3.mapTexture;
              createTexture2D = this.rendererService.createTexture2D;
              this.texture = createTexture2D({
                height: 0,
                width: 0
              });
              if (!mapTexture) {
                _context3.next = 5;
                break;
              }
              return _context3.abrupt("return", new Promise(function (resolve, reject) {
                var image = new Image();
                image.crossOrigin = 'anonymous';
                image.src = mapTexture;
                image.onload = function () {
                  _this.texture = createTexture2D({
                    data: image,
                    width: image.width,
                    height: image.height,
                    wrapS: _l7Core.gl.CLAMP_TO_EDGE,
                    wrapT: _l7Core.gl.CLAMP_TO_EDGE,
                    min: _l7Core.gl.LINEAR,
                    mag: _l7Core.gl.LINEAR
                  });
                  return resolve(null);
                  // this.layerService.reRender();
                };

                image.onerror = function () {
                  reject(new Error('image load error'));
                };
              }));
            case 5:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function loadTexture() {
        return _loadTexture.apply(this, arguments);
      }
      return loadTexture;
    }()
  }]);
  return ExtrudeModel;
}(_BaseModel2.default);
exports.default = ExtrudeModel;