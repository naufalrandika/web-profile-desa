"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.clearActiveStates = exports.resetBaseStates = exports.resetEdgeStates = exports.resetNodeStates = exports.refreshRelatedEdges = exports.setItemState = exports.clearItemsStates = exports.clearItemStates = exports.paintOnce = exports.setItemStateStyle = exports.getEdgeStateStyles = exports.getNodeStateStyles = void 0;
var types_1 = require("../types");
var edge_1 = require("./edge");
var constants_1 = require("../constants");
// 获取节点状态样式
var getNodeStateStyles = function (state) {
    var _a;
    var stateStyles = (_a = {},
        _a[types_1.ITEM_STATE.Selected] = {
            'node-key-shape': {
                lineWidth: 14,
            },
            'node-inner-border-shape': {
                lineWidth: 2,
            },
        },
        _a[types_1.ITEM_STATE.Active] = {
            'node-key-shape': {
                lineWidth: 6,
            },
            'node-inner-border-shape': {
                lineWidth: 1,
            },
        },
        _a[types_1.ITEM_STATE.Default] = {
            'node-key-shape': {
                lineWidth: 0,
            },
            'node-inner-border-shape': {
                lineWidth: 1,
            },
        },
        _a);
    return __assign({}, stateStyles[state]);
};
exports.getNodeStateStyles = getNodeStateStyles;
// 获取边line的状态样式
var getEdgeStateStyles = function (state, edge) {
    var _a;
    var _b = edge.style, highlightColor = _b.highlightColor, stroke = _b.stroke, labelFill = _b.labelFill;
    var stateStyles = (_a = {},
        _a[types_1.ITEM_STATE.Selected] = {
            'path-shape': {
                stroke: highlightColor,
                endArrow: (0, edge_1.getArrowConfig)(highlightColor),
            },
            'label-shape': {
                fill: highlightColor,
            },
        },
        _a[types_1.ITEM_STATE.Active] = {
            'path-shape': {
                stroke: highlightColor,
                endArrow: (0, edge_1.getArrowConfig)(highlightColor),
            },
            'label-shape': {
                fill: highlightColor,
            },
        },
        _a[types_1.ITEM_STATE.Default] = {
            'path-shape': {
                stroke: stroke,
                endArrow: (0, edge_1.getArrowConfig)(stroke),
            },
            'label-shape': {
                fill: labelFill,
            },
        },
        _a);
    return __assign({}, stateStyles[state]);
};
exports.getEdgeStateStyles = getEdgeStateStyles;
// 设置元素状态样式
var setItemStateStyle = function (item, type) {
    var _a;
    // 获取元素的数据模型
    var model = item.getModel();
    var states = item.getStates();
    // 获取元素状态
    var state = states[states.length - 1] || types_1.ITEM_STATE.Default;
    // 获取元素在该state下的各shape的style
    var style = type === 'node' ? (0, exports.getNodeStateStyles)(state) : (0, exports.getEdgeStateStyles)(state, model);
    // 获取元素的所有shape
    var shapes = (_a = item.getContainer()) === null || _a === void 0 ? void 0 : _a.get('children');
    // 更新各shape的style
    shapes === null || shapes === void 0 ? void 0 : shapes.forEach(function (shape) {
        var shapeName = shape.get('name');
        if (style[shapeName]) {
            shape.attr(style[shapeName]);
        }
    });
};
exports.setItemStateStyle = setItemStateStyle;
// 一次绘制
var paintOnce = function (graph, fn) {
    var autoPaint = graph.get('autoPaint');
    graph.setAutoPaint(false);
    fn();
    graph.paint();
    graph.setAutoPaint(autoPaint);
};
exports.paintOnce = paintOnce;
// 清空元素状态
var clearItemStates = function (graph, graphItem, states, enablePaint) {
    if (enablePaint === void 0) { enablePaint = false; }
    function fn() {
        states.forEach(function (state) {
            if (graphItem === null || graphItem === void 0 ? void 0 : graphItem.hasState(state)) {
                graph.setItemState(graphItem, state, false);
                // item.setState(state, false);
                // 对尺寸 style 有影响的 state 才需要 refresh ，重新计算位置和边界
                // if (Size_IMPACT_STATES.includes(state)) {
                graphItem.refresh();
                // }
            }
        });
    }
    if (enablePaint) {
        (0, exports.paintOnce)(graph, function () {
            fn();
        });
    }
    else {
        fn();
    }
};
exports.clearItemStates = clearItemStates;
// 清空指定元素集合的状态
var clearItemsStates = function (graph, items, clearStates, enablePaint) {
    if (enablePaint === void 0) { enablePaint = false; }
    function fn() {
        items.forEach(function (graphItem) {
            try {
                (0, exports.clearItemStates)(graph, graphItem, clearStates, false);
            }
            catch (error) {
                console.log('error :>> ', graphItem, error);
            }
        });
    }
    if (enablePaint) {
        (0, exports.paintOnce)(graph, function () {
            fn();
        });
    }
    else {
        fn();
    }
};
exports.clearItemsStates = clearItemsStates;
// 设置元素状态
var setItemState = function (graph, graphItem, state, value, enablePaint) {
    if (enablePaint === void 0) { enablePaint = false; }
    function fn() {
        var _a;
        if (!graphItem || graphItem.destroyed) {
            return;
        }
        graph.setItemState(graphItem, state, value);
        // 对style有影响，重新计算位置和边界
        if (!((_a = graphItem.getKeyShape()) === null || _a === void 0 ? void 0 : _a.get('destroyed')) && constants_1.SIZE_IMPACT_STATES.includes(state)) {
            graphItem.refresh();
        }
    }
    if (enablePaint) {
        (0, exports.paintOnce)(graph, function () {
            fn();
        });
    }
    else {
        fn();
    }
};
exports.setItemState = setItemState;
// 重绘节点相关的边
var refreshRelatedEdges = function (node) {
    node.getEdges().forEach(function (edge) {
        var _a;
        if (!((_a = edge.getKeyShape()) === null || _a === void 0 ? void 0 : _a.get('destroyed')) && edge.get('keyShape')) {
            edge.refresh();
        }
    });
};
exports.refreshRelatedEdges = refreshRelatedEdges;
// 重置所有节点的状态到默认认态
var resetNodeStates = function (graph, enablePaint) {
    if (enablePaint === void 0) { enablePaint = false; }
    // 由于状态的变化，可能会造成 style 的变化，特别是大小的变化，因此在重置了 node 之后，还需要 refresh 关联的边，否则会造成边的终点连接不到节点边界
    var relatedEdges = new Set();
    var resetNodes = function () {
        constants_1.BASE_STATES.forEach(function (state) {
            var stateNodes = graph.findAllByState('node', state);
            stateNodes.forEach(function (node) {
                (0, exports.clearItemStates)(graph, node, [state], false);
                if (constants_1.SIZE_IMPACT_STATES.includes(state)) {
                    node.getEdges().forEach(function (edge) { return relatedEdges.add(edge); });
                }
            });
        });
        Array.from(relatedEdges).forEach(function (edge) {
            edge.refresh();
        });
    };
    if (enablePaint) {
        (0, exports.paintOnce)(graph, resetNodes);
    }
    else {
        resetNodes();
    }
};
exports.resetNodeStates = resetNodeStates;
// 重置所有边的状态到默认状态
var resetEdgeStates = function (graph, enablePaint) {
    if (enablePaint === void 0) { enablePaint = false; }
    (0, exports.clearItemsStates)(graph, graph.getEdges(), constants_1.BASE_STATES, enablePaint);
};
exports.resetEdgeStates = resetEdgeStates;
// 重置为默认状态
var resetBaseStates = function (graph, enablePaint) {
    if (enablePaint === void 0) { enablePaint = false; }
    (0, exports.resetNodeStates)(graph, enablePaint);
    (0, exports.resetEdgeStates)(graph, enablePaint);
};
exports.resetBaseStates = resetBaseStates;
// 清空激活状态
var clearActiveStates = function (graph, enablePaint) {
    if (enablePaint === void 0) { enablePaint = false; }
    (0, exports.clearItemsStates)(graph, graph.getNodes(), [types_1.ITEM_STATE.Active], enablePaint);
    (0, exports.clearItemsStates)(graph, graph.getEdges(), [types_1.ITEM_STATE.Active], enablePaint);
};
exports.clearActiveStates = clearActiveStates;
