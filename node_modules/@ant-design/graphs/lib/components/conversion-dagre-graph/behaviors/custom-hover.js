"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var g6_1 = __importDefault(require("@antv/g6"));
var utils_1 = require("../utils");
var types_1 = require("../types");
g6_1.default.registerBehavior('conv-hover', {
    getDefaultCfg: function () {
        return {
            highlightData: {
                nodes: [],
                edges: [],
                // 触发高亮的节点id
                nodeId: null,
            },
        };
    },
    getEvents: function () {
        return {
            'node:mouseenter': 'onNodeMouseEnter',
            'node:mouseleave': 'onNodeMouseLeave',
            'node:mousemove': 'onNodeMouseMove',
            'edge:mouseenter': 'onEdgeMouseEnter',
            'edge:mouseleave': 'onEdgeMouseLeave',
        };
    },
    handleNodeNameTooltip: function (event) {
        var shape = event.target;
        // hover节点名称时emit事件，用于节点名称的tooltip的展示和隐藏
        if (shape.get('name') === 'node-name') {
            this.graph.emit('node:nametooltipshow', __assign(__assign({}, event), { type: 'node:nametooltipshow', name: 'node:nametooltipshow' }));
        }
        else {
            this.graph.emit('node:nametooltiphide', __assign(__assign({}, event), { type: 'node:nametooltiphide', name: 'node:nametooltiphide' }));
        }
    },
    onNodeMouseEnter: function (event) {
        this.handleNodeNameTooltip(event);
        var currentNode = event.item;
        var model = currentNode.getModel();
        if (!currentNode || currentNode.destroyed || model.disabled)
            return;
        var states = currentNode.getStates();
        if (states.length)
            return;
        if (!this.highlightData.nodeId) {
            this.highlightData = {
                nodes: this.graph.getNodes().map(function (node) { return node.getModel(); }),
                edges: this.graph.getEdges().map(function (edge) { return edge.getModel(); }),
            };
        }
        // 高亮节点相关链路
        this.highlightPath(currentNode, this.highlightData.edges);
    },
    onNodeMouseLeave: function (event) {
        var _this = this;
        // 清空所有元素的激活状态
        (0, utils_1.paintOnce)(this.graph, function () {
            (0, utils_1.clearActiveStates)(_this.graph);
        });
        this.highlightData = {
            nodes: [],
            edges: [],
            nodeId: null,
        };
    },
    onNodeMouseMove: function (event) {
        this.handleNodeNameTooltip(event);
    },
    onEdgeMouseEnter: function (event) {
        var _this = this;
        var currentEdge = event.item;
        var model = currentEdge.getModel();
        if (!currentEdge || currentEdge.destroyed || model.disabled)
            return;
        var states = currentEdge.getStates();
        if (states.length)
            return;
        (0, utils_1.paintOnce)(this.graph, function () {
            (0, utils_1.setItemState)(_this.graph, currentEdge, types_1.ITEM_STATE.Active, true);
            // 提升边层级
            currentEdge.toFront();
        });
    },
    onEdgeMouseLeave: function (event) {
        var edge = event.item;
        (0, utils_1.setItemState)(this.graph, edge, types_1.ITEM_STATE.Active, false);
    },
    // 高亮节点相关的链路
    highlightPath: function (currentNode, queriedEdges) {
        var _this = this;
        if (queriedEdges === void 0) { queriedEdges = []; }
        var currentNodeId = currentNode.getModel().id;
        var _a = this.highlightData, lastNodeId = _a.nodeId, lastHighlightEdges = _a.edges;
        // 要高亮节点与上一次高亮节点一样，同时相关路径也一样，则不再触发高亮操作
        if (lastNodeId === currentNodeId && queriedEdges === lastHighlightEdges) {
            return;
        }
        var _b = (0, utils_1.getInOutPathEdges)(currentNodeId, queriedEdges), relativeOutEdges = _b.relativeOutEdges, relativeInEdges = _b.relativeInEdges;
        var relativeNodeIds = new Set();
        relativeOutEdges.forEach(function (edge) {
            relativeNodeIds.add(edge.source);
            relativeNodeIds.add(edge.target);
        });
        var relativeEdgeIds = relativeOutEdges.map(function (edge) { return edge.id; });
        (0, utils_1.paintOnce)(this.graph, function () {
            relativeEdgeIds.forEach(function (edgeId) {
                var edge = _this.graph.findById(edgeId);
                (0, utils_1.setItemState)(_this.graph, edge, types_1.ITEM_STATE.Active, true);
                // 置顶
                edge.toFront();
            });
            (0, utils_1.setItemState)(_this.graph, currentNode, types_1.ITEM_STATE.Active, true);
            // 提升节点层级
            currentNode.toFront();
        });
        this.highlightData = {
            nodeId: currentNodeId,
            edges: relativeOutEdges,
            nodes: relativeNodeIds,
        };
    },
});
